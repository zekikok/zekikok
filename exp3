/*
------------------------------------------------------------------------------------------------------------------------

	Tür (type): Bir değişkenin içerisindeki değerin hangi formatta tutulduğunu ve bellekte ne kadar uzunlukta (byte) yer
	ayrılacağını belirten kavramdır. Go'da genel olarak türler şu şekilde kategorize edilmiştir:
	- Boolean types
	- Numeric types
	- String types
	- Derived types

	Bu kategoriler konular içerisinde ele alınacaktır

------------------------------------------------------------------------------------------------------------------------
*/
/*
------------------------------------------------------------------------------------------------------------------------

    Anahtar Notlar: Go'da bazı durumlar sistemden sisteme değişiklik gösterebilmektedir. Örneğin int türünün uzunluğu
    bazı sistemlerde 4 byte iken, bazı sistemlerde 8 byte olarak ele alınmaktadır. Şüphesiz farklı byte uzunluğunda da
    olabilir. Bu duruma genel olarak "implementation specified/defined/dependent" denilmektedir.

------------------------------------------------------------------------------------------------------------------------
*/

/*
------------------------------------------------------------------------------------------------------------------------

    Sayısal (Numeric) türler şunlardır:

    Tür ismi                    Uzunluğu (byte)
    int8                            1
    uint8                           1
    int16                           2
    uint16                          2
    int32                           4
    uint32                          4
    int64                           8
    uint64                          8
    byte                            1
    rune                            4
    uint                           4/8
    int                            4/8

    float32                         4
    float64                         8
    complex64                       8
    complex128                     16

    bool                            1

    - Sayısal türler (numeric types) genel olarak iki gruba ayrılır: tamsayı türleri (integer/integral types),
    gerçek sayı türleri (real types/floating point types)

    - Tamsayı türleri işaretli (signed) ve işaretsiz (unsigned) olarak ayrı ayrı bulundurulmuştur ve ikiye tümleme formatında
    çalışırlar.

    - Gerçek sayı türleri ise IEEE754 formatını kullanırlar

    - complex64 türü gerçek (real) ve sanal (imaginary) kısımları float32 türünden olan karmaşık sayıyı temsil eder

    - complex128 türü gerçek (real) ve sanal (imaginary) kısımları float64 türünden olan karmaşık sayıyı temsil eder

    - int8, uint8, int16, uint16, int32, uint32, int64, uint64 tamsayı türlerinin uzunlukları sistemden sisteme değişiklik
    göstermez

    - float32, float64, complex64 ve complex128 türlerinin uzunlukları sistemden sistemden sisteme değişmez.

    - byte türü uint8 türünün ayrı bir ismidir (alias)

    - rune türü int32 türünün ayrı bir ismidir (alias)

    - int ve uint türleri sistem sisteme uzunluğu değişebilen (4 byte veya 8 byte) olan tamsayı türleridir.

    - bool türü 1 byte uzunluğunda, true veya false değerlerinden birini alabilen bir türdür.

    - Yukarıdakiler temel standart türlerdir. Diğer standart türler ayrı ele alınacaktır

------------------------------------------------------------------------------------------------------------------------
*/



//****  file, function, block scope 
//****  masking /shadowing  ,  name lookup

package main
import "fmt"

var a int = 10           // Diğer paketlerden  görülmez (File scope)
var Yas int = 20        //  Diğer paketlerden de görülebilir . (degisken adının ilk karakteri (Y) büyük harf olduğu için) 

//    b := 20     ERROR  : Global alanda := kullanılamaz. 

func foo() {
	fmt.Println(" a file scope (a foo da tanımlanmadigi için glabal a geçerli ) a= ", a)
}

func main() {
	var a int = 20
	fmt.Println("func scope (main) a= ", a)

	if true {
		var a int = 30
                var b int = 11
		fmt.Println("block scope   a= ", a)
		fmt.Println("block scope   b= ", b)
	}

	fmt.Println("func scope (main) a= ", a)

	foo()

	fmt.Println("func scope (main) a= ", a)

  //  fmt.Println("b= ", b)   // compile sırasında  error b tanımlanmamış. yukarıda if blogundaki b,  block scope yani sadece o blokta kullanılabilir.

}

/*  ekran çıktısı
func scope (main) a=  20
block scope   a=  30
block scope   b=  11
func scope (main) a=  20
 a file scope (a foo da tanımlanmadigi için glabal a geçerli ) a=  10
func scope (main) a=  20
 
*/


// ***    type conversion ***
package main
import "fmt"
func main() {
	var a int16 = 130
	var b int8
	b = int8(a)
	fmt.Println(b) 

  //  -126 yazar     130 int8 sınırları içinde değildir.
  //  büyük tipten küçük tipe dönüşümde dikkatli olunması gerekir...

// istisna numericten stringe dönüştürme  ascii karakter için geçerli
  n   := 65
  str := string(n)
  fmt.Printf("%v %T", str, str)    // Ekrana  A string yazar.

// sayilari dizgeler dönüştüren metotlar vardır..
// örnek :  strconv paketindeki  strconv.Itoa(12)

 y := strconv.Itoa(n)
 fmt.Printf("%v, %T", y, y)    // ekrana  65, String yazar

}


/*********
    a := 30      // default  a   int
    b := 10.2    //   ""     b   float64  
*/


/*****    Tür dönüşümü
  x := 10
  y :=  4
	fmt.Printf("%v, %v", x, y)
  y,x = x,y
	fmt.Printf("%v, %v", x, y)
 
   a := 10/4
   b := float64(10/4)
   c := 10.0 /4 
	  fmt.Printf("%T, %v", a, a)
	  fmt.Printf("%T, %v", b, b)
  

  a := 10 / 4
	b := float64(10 / 4)
	c := 10.0 / 4
	fmt.Printf("%T, %v", a, a)
	fmt.Printf("%T, %v", b, b)
	fmt.Printf("%T, %v", c, c)

x, y := 15.0, 3

	fmt.Printf("%T, %v", (15.0 / 3), (15.0 / 3))
	fmt.Printf("%T, %v", (x / y), (x / y))

/***************
Go teknik ingilizce   %  : remainder operatoru


/*****************
var  x int = 10
	fmt.Println(x++)

var  a int = 6
var  b int = 5
b= 10+ (a++)
fmt.Printf("%T, %v\n", b, b)  ????


İfade (expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan dizilimlere denir.

Expression ile Statement arasındaki fark

Statements    print "hello"  , x = 1
Expression    5*5
Expression Statement   print 5*5  

x := 1+3
fmt.Println(x=1+3)   ???????????

***  GO  da bir satırda bir statement olabilir

Go da   x++ ,  x--    nedir ?????
var  x int  = 10
	fmt.Println(x++)   // unexpected error

/**** CONSTANTS
const  : compile time sırasında
var    : Runtime      ""

x := 5
const y = x  //    Error   x:=5 runtime da yapilan bir işlem.  const y=x   compile time sırasında x belli değil.. 
o zaman const a  = ??    (?? burada sabit olmalı)

const x = 5
y := x  
  fmt.Printf("%T, %v", y, y)
 

/***    TYPELESS CONSTANTS
/*  Code A
const x int8 = 4
var y int16 = 10
	fmt.Printf("%T, %v \n", x, x)
	fmt.Printf("%T, %v\n ", y, y)
	//	fmt.Printf("%T, %v", x+y, x+y)

/*  Code B
const x = 4
	var y int16 = 10
	fmt.Printf("%T, %v \n", x, x)
	fmt.Printf("%T, %v \n", y, y)
	fmt.Printf("%T, %v", x+y, x+y)

Code A ile Code B  yi    Açıkla.  Aradaki fark var mı ? 

const x = 6.3 + 2
	fmt.Printf("%T, %v\n", x, x)

const y int16 = (6.3 + 2.7)
	fmt.Printf("%T, %v\n", y, y)


const a = 6.3
const b = 5
	fmt.Printf("%T, %v\n", a+b, a+b)

const c float64 = 5.25
d := 4 + c
	fmt.Printf("%T, %v\n", d, d)

/***    CONSTANTS  shadowing / masking

package main

const x = 5

func main() {
  const x = 33
  fmt.Printf("%T, %v", x, x)

} 

/* 
Teknik ingilizce 
==   Equal       
!=   Not Equal
<    Less Than
<    Greater Than
<=   Less Than or Equal
>=   Greater Than or Equal

Mismatched type : Tür uyuşmazlığı

GO  :  Biribirene atanabilen 2 değer karşılaştırlabilir.   (Tip uyumu)
       Conditional operators ile elde edilen sonuç boolean tiptir. (bool) yani true veya false. 

x, y := 3, 7

a1 := (x == y)
a2 := (x < y)
	fmt.Printf("%T, %v\n", a1, a1)
	fmt.Printf("%T, %v\n", a2, a2)
         fmt.Printf("%T, %v\n", a1 && a2, a1 && a2)

a3 := 20
fmt.Printf("%T, %v",a1 && a3, a1 && a3 )   // Error  a1 bool , a3 int  

/** GO' da   Zero -Non zero ?????
 /** Go da   one - non one       1 : True   diğerleri False 


/** String to Boolean Conversion
str := "1"      
	x, _ := strconv.ParseBool(str)
	fmt.Printf("%T, %v\n", x, x)  // ekrana bool, true yazar

//  str ye "1" dışında atanacak tüm sitringler  false üretiyor ==>  "01", "+1", "2" ,"0", "-1", "3355", "a", "ali", .... gibi

}



/******** C Dilinde CONSTANT ADRES

#include <stdio.h>
int main()
{
    const  int a = 20 ;
    int * ptr  = (int*)  &a ;   // legal   AMA YANLIS
    printf("%p %d", &ptr, *ptr) ;
    *ptr = 34567 ;  // ub : tanımsız davranıs 
}

/*  GO Const adresi alınamıyor...
package main
import "fmt"

func main() {
   const   a int = 20 ;
   ptr :=   &a ;   // invalid operation: cannot take address of a (constant 20 of type int)
   fmt.Println("%T %v\n", ptr, ptr)
   fmt.Println("%T %v\n", &a, &a)

} 

/*
------------------------------------------------------------------------------------------------------------------------

	Go'da sonlandırıcı (terminator) bir sonraki satıra geçmek veya ; kullanılabilir. Programcı ;'ü gerekmedikçe tercih
	etmemelidir. Aşağıdaki örnekte bir sonraki satıra geçilmediği için noktalı virgül kullanılmalıdır. Aksi durumda
	compile time error oluşur

------------------------------------------------------------------------------------------------------------------------
*/

package main
import "fmt"
func main() {
	var a, b int
	fmt.Print("Input two numbers:"); fmt.Scan(&a, &b)

	a *= b + 2 //a = a * (b + 2)
	fmt.Printf("a = %d, b = %d\n", a, b)
}

/*
------------------------------------------------------------------------------------------------------------------------

	Go'da etkisiz ifadeler genel olarak compile time error oluşturur (code has no effect)

package main
func main() {
	var a, b = 10, 20
	a + b //error
}

------------------------------------------------------------------------------------------------------------------------

	Deyimler (Statements): Bir programın çalıştırılabilen parçasına denir. Program aslında deyimlerin çalıştırılmasıyla
	çalışır. Go'da deyimler şunlardır:
	1. Basit deyimler (simple staments): Bir ifadenin sonuna noktalı virgül konması ve bir sonraki satıra geçilmesi
	ile oluşan deyimdir. Basit deyim çalıştırıldığında ilgili ifade hesaplanır

	2. Bileşik deyimler (compound statements): Bir bloğa denir. Bu anlamda fonksiyon gövdesi de bir bileşik deyimdir.
	Bileşik deyim çalıştırıldığında blok içerisindeki tüm deyimler sırasıyla çalıştırılır

	3. Bildirim deyimleri (declaration statements): Değişken bildirimine ilişkin deyimlerdir. Bildirim deyimleri
	çalıştırıldığında bellekte yer ayrılır

	4. Kontrol deyimleri (control statements): Akışın yönlendirilmesine yol açan deyimlerdir. Her kontrol deyiminin
	kendine özgü bir çalışma sistematiği vardır. Ayrıca öğrenilmelidir

	5. Boş deyim (Empty/null statement): Aslında Go'da çok kullanılmasa da ;'ün kendisi bir boş deyimdir. Boş deyim
	çalıştırıldığında hiç bir şey yapılmaz


------------------------------------------------------------------------------------------------------------------------

	if deyimi (if statement): if deyimi en temel kontrol deyimidir. if deyiminin genel biçimi şu şekildedir:
		if [(]<bool türden ifade>[)] {
			//...
		} [else {
			//...
		}]

	Burada {'leri ve varsa else kısmı belirtilen yerinde olmalıdır. Ayrıca if deyiminde (aslında bütün kontrol deyimlerinde)
	basit deyim yazılamaz. Her zaman bileşik deyim yazılmalıdır. if else kısmıyla birlikte tejk bir deyimdir

------------------------------------------------------------------------------------------------------------------------
*/

func main() }

//  x:= 30
	 if x := -3 ; x < 0 {
		fmt.Println(x, " negatif saydir")
	 else if x%2==0 {
		fmt.Println(x, " çift saydir")
	 } else {
		fmt.Println(x, " tek saydir")
	 }

    fmt.Println(x)   // Error undefined x ..    x if deyimi içerisinde tanımlanmıs. bu deyime bağlı blokta kullanılabilir. block scope

// En üsteki  x:=30 yazan satırdaki // yı kaldırırsak ekrana 30 yazar...

}

------------------------------------------------------------------------------------------------------------------------

Anahtar Notlar: Programlamada bir durumu ve doğru ya da yanlış değeri elde edilmesine yol açan kavrama "predicate"
		denir. Bu anlamda geri dönüş değeri bool olan fonksiyonlar da predicate fonksiyonlardır

Anahtar Notlar: geri dönüş değeri bool olan fonksiyonlar genel olarak is gibi önekler verilerek isimlendirilir. Eğer
  		fonksiyon ismi bir fiil ise bu durumda o fiil uygun şekilde kullanılır. Örneğin: exists gibi

------------------------------------------------------------------------------------------------------------------------
*/




